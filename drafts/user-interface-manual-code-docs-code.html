<!DOCTYPE html>
<html lang="en">
<head>
 <title></title>
 <meta charset="utf-8">
 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
 <meta id="keywords" name="keywords" content="">
        
 <link id="stylesheet" rel="stylesheet" type="text/css" href="https://oskipa.github.io/theme/css/code.css"></link>
 <link id="stylesheet" rel="stylesheet" type="text/css" href="https://oskipa.github.io/theme/css/site.css"></link>


</head>
<body>
   <header class="header">
      <h1 class="site-name"> 
        <a class="home-link" href="https://oskipa.github.io">Dada</a><br /> 
        |&gt Structures<br />
        |&gt Algorithms</h1>

      <nav>
      <menu class="minimal-menu">
        <li><a href="https://oskipa.github.io/pages/today-i-learned.html">til</a></li>
        <li><a href="https://oskipa.github.io/short_index.html">index</a></li>
          <!--
        <li><a href="category/log.html">web log<a></li>
        <li><a href="">about<a></li>
        <li><a href="">site map<a></li>
          -->
      </menu>
    </nav>


    </header>
    
 <div class="container">
<div class="row">
 <div class="col-md-8">
  <h2>User Interface > Manual > Code Docs > Code</h2>
  <h3>Improve your software by finding where users consult lower levels of abstraction</h3>
  <label>18 March, 2020</label>
  <ol>
<li>Levels of abstraction</li>
<li>Dropping to a lower level of abstraction means that the higher one's can be improved</li>
<li>Cars as a model of good implementation of abstraction</li>
<li>Software compared to cars</li>
</ol>
<p>This post is about software. It is about how to find spots for improving your software interfaces. </p>
<p>However, I want to talk about cars first because I think it is a model of successful user interface design and documentation.</p>
<p>The user interface for driving a car is well known. You sit behind the wheel. You check visibility on your windshield.  You check the mirrors. You release the emergency break. You start the car. You get into the right gear. You use the wheel to turn and the pedals to accelerate, break, or shift gears. You have some indicators like speedometer to tell you how fast you go and the fuel tank indicator to let you know when you need to refuel.</p>
<p>It is a common interface, so you can usually hop into any car and drive it. There are some complicated vehicles, like trailer trucks which need a more complex system, but the conventions are about the same.</p>
<p>If there is something that you can't figure out, you reach for the user manual. Let's say you got in a new car, and you can't find how to turn the emergency lights on. You open the user manual, and find out that it is the yellow button by the radio.</p>
<p>If you need to replace a light, you can try doing it. If you fail, and you can't figure out how to do it, you open the repair manual. You will open the hood and try to fix it. In extreme cases you need to look at the diagrams on how the car is put together.</p>
<p>But about 98 to 99 percent of the time, you will sit down and drive. You don't need to do any of the above.</p>
<p>The modern car is a success in user interface design. Over one hundred years we have developed a number of conventions. Once a person learns them, they can quickly adapt moving from one vehicle to another. User manuals usually are used as references for learning specifics about the conventions. We consult them when we want to see what grade of oil to use, what the pressure of the tires should be. In some cases user manuals will have how to fix some known issues that have simple workarounds.</p>
<p>Let's get back to software. How can we apply the success of car design to software? Let's make a simple chart to illustrate the different levels of abstraction that the driver and our software users interact with.</p>
<hr>
<h2>|Abstraction            | Car                           | Software|</h2>
<p>|User Interface| Steering wheel, pedals | GUI, command line, API |
|User manual   | Owners manual | User guides, tutorials, readmes |
|Documentation | Repair manual | StackOverflow, library docs     |
|Implementation| Opening the hood to check the system| Source code|  <br>
|Expert| Asking an expert mechanic| Asking the author|    </p>
<p>Cars are successful because the user is kept most of the time at the user interface level of abstraction. Learning more about the car is a user's choice. Yes, the ones that learn more about it will get better performance and gas millage. Yet if all what a user wants is go to work and come back, they can do it without having to do research. </p>
<p>With software we are still in the process of creating many of these conventions. So it can be more jarring moving from one product to another.That said, windowed systems, spreadsheets, and lists, and swiping right or left are emerging conventions.</p>
<p>Dropping down to the user manual points out some kind of failure in the design or implementation. My smart car will stop working if there are too many keys in the keychain. The car will stop and it won't start again. The user manual tells us to sing "This little sun of mine" to the car to encourage it to start again. After that song, the car will start.</p>
<p>And here is the first opportunity: can you design your software so that people can start using your software without training. Figure out what conventions people expect. Stick to those.</p>
<p>The equivalent of the repair manual for a car would be the reference documentationand technical articles describing the system. Reference documentation would be a list of methods and their documentation. Elixir's documentation is a good model. Technical articles are meant as documentation for maintainers and a tiny minority of advance users. These are meant to help maintainers get an idea of how the system is designed so that they can repair or expand it. </p>
<p>If users are hitting too much the reference documents and the technical articles, it may be hinting that we can improve the user guides. If some reference page is seen too much, then perhaps a user guide on that object should be created. If a techincal article is read too much, perhaps that is missing information that a user needs to operate the system.</p>
<p>Next we have the source code. This is the core of how things are put together.
This the equivalent of looking at the motor, the hoses, and electrical systems in a car. There are some cars that are easier to work with than others. In some, everything is cramped up together. In others, the designers put enough space so that it is easy to work. We can do the same for our code.</p>
<p>If people are reading your source code to see why something isn't working, that means that your documentation can improve. Just as you should create a test and fix a bug, documentation should be upgraded at this point.</p>
<p>If team members as you many times to explain some part of the code, this is an indications that an technical article should be written. Or that we need to add some comments. Or that the code can be improved. Or, if it is not understandable because of a new feature, that some training is in order. Strive to write code that is easy to code.</p>
 </div>
</div>
 </div> 
 
 <footer class="footer">

   <!-- <p class="about"><a href="http://hugoestr.github.io/blog/manifesto.html">About</a> --> <a href="https://oskipa.github.io/pages/about.html" >I am</a> a software developer. I code in Python, Lisp, and many other languages.  I like poetry, museums, and ukuleles. I try to guide my life on  principles of dadaism and nonviolence.</p>
        <p>
          <a href="feeds/all.atom.xml">atom</a>
          <a href="http://github.com/oskipa/">github</a>
        </p> 

        <p>Artisanally built with <a href="https://blog.getpelican.com/">Pelican</a>. Content handcrafted in <a href="https://www.vim.org/" >Vim</a>. All hallucinations are human. 100% AI Free.</p>
      </footer>

</body>
</html>