<!DOCTYPE html>
<html lang="en">
<head>
 <title></title>
 <meta charset="utf-8">
 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
 <meta id="keywords" name="keywords" content="">
        
 <link id="stylesheet" rel="stylesheet" type="text/css" href="https://oskipa.github.io/theme/css/code.css"></link>
 <link id="stylesheet" rel="stylesheet" type="text/css" href="https://oskipa.github.io/theme/css/site.css"></link>


</head>
<body>
   <header class="header">
      <h1 class="site-name"> 
        <a class="home-link" href="https://oskipa.github.io">Dada</a><br /> 
        |&gt Structures<br />
        |&gt Algorithms</h1>

      <nav>
      <menu class="minimal-menu">
        <li><a href="https://oskipa.github.io/pages/today-i-learned.html">til</a></li>
        <li><a href="https://oskipa.github.io/short_index.html">index</a></li>
          <!--
        <li><a href="category/log.html">web log<a></li>
        <li><a href="">about<a></li>
        <li><a href="">site map<a></li>
          -->
      </menu>
    </nav>


    </header>
    
 <div class="container">
<div class="row">
 <div class="col-md-8">
  <h2>Python's yield</h2>
  <h3>Some notes on what it is and how it works</h3>
  <label>30 July, 2020</label>
  <h2>The short answer</h2>
<p>Python's 'yield' is used instead of 'result' when you are creating results via a generator function. Think of generators as some sort of a lazy, stateful function that returns one item at a time. Why would we want that? We would want this when consuming a huge amount of data that can't be loaded all at once into memory. Think of a giant csv file. </p>
<p>So the point of a generator is to have a function that can give you one item at a time and remember where it was the next time you call it.  </p>
<p>Here is an example:</p>
<div class="highlight"><pre><span></span><code>    <span class="o">&gt;&gt;&gt;</span> # <span class="nv">we</span> <span class="nv">create</span> <span class="nv">our</span> <span class="nv">generator</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="nv">def</span> <span class="nv">up_to_10</span><span class="ss">()</span>:
    ...   <span class="k">for</span> <span class="nv">n</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="mi">10</span><span class="ss">)</span>:
    ...     <span class="nv">yield</span> <span class="nv">n</span>
    ...
    <span class="o">&gt;&gt;&gt;</span> # <span class="nv">we</span> <span class="nv">use</span> <span class="nv">it</span> 
    <span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="nv">i</span> <span class="nv">in</span> <span class="nv">up_to_10</span><span class="ss">()</span>:
    ...   <span class="nv">print</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span>
    ...
    <span class="mi">0</span>
    <span class="mi">1</span>
    <span class="mi">2</span>
    <span class="mi">3</span>
    <span class="mi">4</span>
    <span class="mi">5</span>
    <span class="mi">6</span>
    <span class="mi">7</span>
    <span class="mi">8</span>
    <span class="mi">9</span>
    <span class="o">&gt;&gt;&gt;</span>
</code></pre></div>

<h2>The longer story</h2>
<p>My example seems silly since we could achieve the same with a range or with a list. My guess is that generators are useful to implement laziness. You could create a library that queries a  database, but will only make the call it when you actually need it. I can also see how we can use generators to create infinite series.</p>
<p>'yield' trips me up coming from Ruby. 'yield' does something different in Ruby: it executes a block that has been passed to the method.</p>
<p>Python's 'yield' seems closer to C#'s yield. Sadly, I never fully understood C#'s yield. From this blog, it looks like it is similar to Pyton's yield. <a href="https://www.kenneth-truyers.net/2016/05/12/yield-return-in-c/">https://www.kenneth-truyers.net/2016/05/12/yield-return-in-c/</a>[3]</p>
<p>You can read more about 'yield' and generators at <a href="https://www.geeksforgeeks.org/use-yield-keyword-instead-return-keyword-python/">https://www.geeksforgeeks.org/use-yield-keyword-instead-return-keyword-python/</a>[1] and at its PEP[2]</p>
<p>References:</p>
<p>[1] A. Agarwal, "When to use yield instead of return in Python?" GeeksForGeeks. <a href="https://www.geeksforgeeks.org/use-yield-keyword-instead-return-keyword-python/">https://www.geeksforgeeks.org/use-yield-keyword-instead-return-keyword-python/</a> (accessed July 30, 2020)</p>
<p>[2] N. Schemenauer, T. Peters, M. Lie Hetland, PEP 255. Python <a href="https://www.python.org/dev/peps/pep-0255/">https://www.python.org/dev/peps/pep-0255/</a>(accessed July 30, 2020)</p>
<p>[3] K. Truyers, <em>Yield return in C#</em>, kenneth-truyers.net, <a href="https://www.kenneth-truyers.net/2016/05/12/yield-return-in-c/">https://www.kenneth-truyers.net/2016/05/12/yield-return-in-c/</a>(accessed July 31, 2020)</p>
 </div>
</div>
 </div> 
 
 <footer class="footer">

   <!-- <p class="about"><a href="http://hugoestr.github.io/blog/manifesto.html">About</a> --> <a href="https://oskipa.github.io/pages/about.html" >I am</a> a software developer. I code in Ruby, Elixir, Python, C#, and many other languages.  I like poetry, museums, and ukuleles. I try to guide my life on  principles of dadaism and nonviolence.</p>
        <p>
          <a href="feeds/all.atom.xml">atom</a>
          <a href="http://github.com/oskipa/">github</a>
        </p> 

        <p>Artisanally built with <a href="https://blog.getpelican.com/">Pelican</a>. Content handcrafted in <a href="https://www.vim.org/" >Vim</a></p>
      </footer>

</body>
</html>