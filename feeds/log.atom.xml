<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dada Structures and Algorithms - log</title><link href="https://oskipa.github.io/" rel="alternate"></link><link href="https://oskipa.github.io/feeds/log.atom.xml" rel="self"></link><id>https://oskipa.github.io/</id><updated>2020-05-30T00:00:00-04:00</updated><entry><title>Goals over Process</title><link href="https://oskipa.github.io/goals-over-process.html" rel="alternate"></link><published>2020-05-30T00:00:00-04:00</published><updated>2020-05-30T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-05-30:/goals-over-process.html</id><summary type="html">&lt;p&gt;Sometimes when we learn a new methodology we become eager to implement it. It is like buying a new board game and being eager to play it with others.  &lt;/p&gt;
&lt;p&gt;In our zeal to implement these methodologies, we may lose track that a methodology is a means to achieve a goal …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Sometimes when we learn a new methodology we become eager to implement it. It is like buying a new board game and being eager to play it with others.  &lt;/p&gt;
&lt;p&gt;In our zeal to implement these methodologies, we may lose track that a methodology is a means to achieve a goal. The displine is not the goal itself. Yet it is so easy to fall into the trap of making the discipline the goals.&lt;/p&gt;
&lt;p&gt;What is the goal of methodologies like agile or waterfall? It is to give some organization to software development. Ideally to create working habits that give managers the information they need while giving workers predictable working environment. &lt;/p&gt;
&lt;p&gt;Ultimately what managers need is to know what is the state of a project in terms of completion and schedule. This is necessary to make decisions to keep a project on schedule. To a lesser extent they need to know how their workers are performing. This is necessary to identify problems and provide training if possible. &lt;/p&gt;
&lt;p&gt;Workers need a reasonable work process. They need to have the necessary autonomy, training, and tools. They need a safe environment so that they can focus on their work rather than office politics.&lt;/p&gt;
&lt;p&gt;Keeping in mind these goals, we can adapt methodology principles to actual workplaces when we join them. &lt;/p&gt;
&lt;p&gt;If a team shares their daily tasks on a slack channel, that fulfills the information needs for the  manager. There isn't a need to introduce a stand up meeting. You may love the stand up ritual, but if you force on people who don't want to do it, they will resent you for wasting their time. At the end of the day the manager is still getting the information they need.&lt;/p&gt;
&lt;p&gt;Process is a tool. If some behavior exists that already fulfill the goal, then the pragmatic decision is to keep that behavior.&lt;/p&gt;</content><category term="log"></category><category term="process"></category></entry><entry><title>Find and Replace Recursively</title><link href="https://oskipa.github.io/find-and-replace-recursively.html" rel="alternate"></link><published>2020-05-27T00:00:00-04:00</published><updated>2020-05-27T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-05-27:/find-and-replace-recursively.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;grep -rl &amp;quot;Chunky&amp;quot; . | LC_ALL=C xargs sed -i &amp;quot;.bak&amp;quot;  &amp;quot;s/Chunky/Bacon/&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Every so often we need to mass edit some directories. That should be the job of sed. Yet sed doesn't find files, so you need another utility. There you have a choice of tools. For this case I …&lt;/p&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;grep -rl &amp;quot;Chunky&amp;quot; . | LC_ALL=C xargs sed -i &amp;quot;.bak&amp;quot;  &amp;quot;s/Chunky/Bacon/&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Every so often we need to mass edit some directories. That should be the job of sed. Yet sed doesn't find files, so you need another utility. There you have a choice of tools. For this case I decided to use grep. Although I use ack for searching patterns, I thought that grep would be the right tool here.&lt;/p&gt;
&lt;p&gt;Now the explanation of the example.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Magical bit&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;grep&lt;/td&gt;
&lt;td&gt;Our second favorite tool for finding patterns in files. Our favorite is ack, but grep is more appropriate here.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-rl&lt;/td&gt;
&lt;td&gt;Our grep options. r = recursive search. l = output the name of the files&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;"Chunky"&lt;/td&gt;
&lt;td&gt;Our pattern&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;The direction we want to search. In this case, start from the current directory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;the pipe&lt;/td&gt;
&lt;td&gt;The magic unix character that lets us pass output into another command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LC_ALL=C&lt;/td&gt;
&lt;td&gt;The esoteric incantation to have sed behave in MacOS. It has to do with encoding&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xargs&lt;/td&gt;
&lt;td&gt;Unix utility to transform standard input into command arguments&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sed&lt;/td&gt;
&lt;td&gt;Our batch editor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;The option to edit in place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;".bak"&lt;/td&gt;
&lt;td&gt;The extension that we want to give to the backup file that sed -i will create&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;"s/Chunky/Bacon/"&lt;/td&gt;
&lt;td&gt;The sed command we want to execute. In this case substitute Chunky with Bacon&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;You can clean up the backup files with &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;grep -rl &amp;quot;Chunky&amp;quot; . | xarg rm -f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="log"></category><category term="shell"></category><category term="unix"></category><category term="linux"></category><category term="macos"></category></entry><entry><title>Why don't we practice self-reflection in Agile?</title><link href="https://oskipa.github.io/agile-self-reflection.html" rel="alternate"></link><published>2020-05-01T00:00:00-04:00</published><updated>2020-05-01T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-05-01:/agile-self-reflection.html</id><summary type="html">&lt;p&gt;Self-reflection is my favorite part from agile. Call it a retrospective or a post-mortem; at the end of the day it is self-reflection. This is the self-correcting mechanism. You see what you have done. If it is not working, you do something else. If it perhaps the essence of agile …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Self-reflection is my favorite part from agile. Call it a retrospective or a post-mortem; at the end of the day it is self-reflection. This is the self-correcting mechanism. You see what you have done. If it is not working, you do something else. If it perhaps the essence of agile. You can give up on everything, but if you keep practicing self-reflection and self-correction, you are doing it correclty. &lt;/p&gt;
&lt;p&gt;It is also the least practiced one. If practiced, it is most likely poorly done. Self-reflection is about accepting reality. Accepting reality is hard. You need three elements for self-reflection to work: maturity to accept reality, safety to point it out, and power to improve things. &lt;/p&gt;
&lt;p&gt;If these conditions don't exist, then doing a retrospective becomes an empty ritual. In the best of cases it is a waste of time. In the worst, it can become a bullying session. In both cases it becomes unpleasant, so people will try to avoid doing it.  &lt;/p&gt;
&lt;p&gt;Accepting reality is the biggest challenge. It takes emotional maturity for individuals and organizations, which are made from those individuals. &lt;/p&gt;
&lt;p&gt;Individually we find it painful to accept reality because we are afraid that it will shatter our self image. We may not be as productive as we were. We may have forgotten a lot about working in css. We may be struggling to learn iOS development. It is common that most of us will rather deny these realities because they force us to change the our self narrative. We avoid this pain.&lt;/p&gt;
&lt;p&gt;Acknowledging these short comings can help us overcome them. If we notice we are less productive, we can start looking for the cause. Maybe we are not sleeping enough. Maybe we need to get a book on css. Maybe asking the iOS developer for help can overcome the change. Yet before we can act on the deficiencies, we need to identify and acknowledge them.  &lt;/p&gt;
&lt;p&gt;We find a similar dynamic as a group, in our teams. Even if we have team members that can handle reality, the team as a whole may not be able to do so. This is where safety and power comes into play. Those in power must make it safe to have team members bring up reality and act on suggestions.&lt;/p&gt;
&lt;p&gt;Let's say that a deadline was missed. The team knows it was missed because the schedule was overly optimistic. If members don't feel safe to point it out because they can be punished for doing so, they won't. People will become yes men out of necessity. Leadership will increasingly find themselves in a parallel reality where their beliefs are reality -- until reality resassess itself, often in painful ways. &lt;/p&gt;
&lt;p&gt;Maybe the team can be mature enough to acknowledge reality, but they lack power to make changes. If a schedule is too optimistic, you need to add more slack to it. But the team manager may not have the power to do that. Or it was identified that the team needs training in a new technology executives decided to adopt. But they won't give them the budget. &lt;/p&gt;
&lt;p&gt;Retrospectives then become a ritual that teaches learned helplessness. People will become jaded. They will resent the ritual because it is meaningless.&lt;/p&gt;
&lt;p&gt;In reality most of us work in places where the conditions are not ideal. What to do? As individuals we can practice self-reflexion ourselves, and act within our power. If it is safe, we can model this with coworkers. This is what each of us can do to foster a culture of self-reflection and safety.&lt;/p&gt;
&lt;p&gt;If you are a manager you have greater power to shape culture. There are two things that are important to create this culture. The first one is to honestly model self-reflection. The stress is on the honesty. The second one is to act on suggestions.&lt;/p&gt;
&lt;p&gt;If you were responsible for the optimistic schedule, you can acknowledge that, and adjust it. Say something like, "I forgot to include slack for people getting sick" or "I didn't take into consideration the mandatory corporte retreat". Then you need to follow through fixing the schedule.&lt;/p&gt;
&lt;p&gt;Let's say that in a retrospective workers say slack is too distracting, and they need 4 hours where they can turn it off so they can focus on work. The manager wants to make sure that people can still be reached within reasonable periods of time. The manager says that they can turn off slack for two hours, check messages and answer them then, and then turn it off for another two hours. The team most likely be pleased. It may not be 4 hours solid, but getting two focus segments are better than none.&lt;/p&gt;
&lt;p&gt;We must keep in mind that power is often limited, so we can sometimes only do modest changes. Hopefully those changes can build up over time and we can then reap the benefits of self-reflection.&lt;/p&gt;</content><category term="log"></category><category term="software-engineering"></category></entry><entry><title>The Five Minutes Problem</title><link href="https://oskipa.github.io/the-five-minutes-problem.html" rel="alternate"></link><published>2020-04-24T00:00:00-04:00</published><updated>2020-04-24T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-04-24:/the-five-minutes-problem.html</id><summary type="html">&lt;p&gt;In fields like chess, math, and computer science, you need to do the problem to learn. You cannot learn just by watching a lecture. It is a skill that one must cultivate via doing.&lt;/p&gt;
&lt;p&gt;But the question is, how much should you spend on a problem that you cannot solve …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In fields like chess, math, and computer science, you need to do the problem to learn. You cannot learn just by watching a lecture. It is a skill that one must cultivate via doing.&lt;/p&gt;
&lt;p&gt;But the question is, how much should you spend on a problem that you cannot solve?&lt;/p&gt;
&lt;p&gt;One school of thought is that you keep at that problem until you can solve it by yourself. It seems to make sense. If you put enough effort, you will discover the solution. Or find a novel one. Unfortunately you may not find a solution, so you can stop playing chess or learning math if you strickly stick to this method.&lt;/p&gt;
&lt;p&gt;A better method is to timebox how much time you spend on solving a puzzle. The rule of thumb is that you should find the basic solution within five minutes. &lt;/p&gt;
&lt;p&gt;For those five minutes, you will attempt to solve the problem all by yourself. You have to give it your all. If you solved it, good! Pat yourself in the back!&lt;/p&gt;
&lt;p&gt;If you don't, you look at the answer. &lt;/p&gt;
&lt;p&gt;If this cheating? No. Problem solving is about pattern recognition. If you couldn't find a solution, you couldn't find a pattern. That means you haven't learned that pattern.&lt;/p&gt;
&lt;p&gt;By spending those earnest five minutes trying to solve the problem, you will understand the problem well. You will understand why your natural solution didn't work. When you look at the solution, it is meaningful. Your emotional reaction to seeing the solution will make it easier for you to remember it, creating that desire pattern for you to recognize the next time you see a similar problem.&lt;/p&gt;
&lt;p&gt;I also learned this tactic by looking at the solution. I found this strategy in a chess book, which in turn adopted it from what seems to be a math teaching tactic in Russia.&lt;/p&gt;</content><category term="log"></category><category term="learning"></category><category term="comp sci"></category><category term="math"></category></entry><entry><title>Looping in Ruby</title><link href="https://oskipa.github.io/looping-in-ruby.html" rel="alternate"></link><published>2020-04-22T00:00:00-04:00</published><updated>2020-04-22T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-04-22:/looping-in-ruby.html</id><summary type="html">&lt;p&gt;Looping in Ruby is usually a delight. The idiomatic way of doing it is via #each on &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;animals.each do |beast|&lt;/span&gt;
&lt;span class="err"&gt;  beast.roar&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sometimes you need the index. So you call in #each_with_index&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;animals.each_with_index do |beast, index|&lt;/span&gt;
&lt;span class="err"&gt;  puts &amp;quot;#{beast} #{index} says: #{beast.roar} &amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you feel functional …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Looping in Ruby is usually a delight. The idiomatic way of doing it is via #each on &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;animals.each do |beast|&lt;/span&gt;
&lt;span class="err"&gt;  beast.roar&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sometimes you need the index. So you call in #each_with_index&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;animals.each_with_index do |beast, index|&lt;/span&gt;
&lt;span class="err"&gt;  puts &amp;quot;#{beast} #{index} says: #{beast.roar} &amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you feel functional, then you can use one of the Enumerable methods.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;animals.map do |beast|&lt;/span&gt;
&lt;span class="err"&gt;  beast.roar&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For 90% of your looping needs, #each, or an Enumerable, #map, #select, #any?, #all?, etc, will do.&lt;/p&gt;
&lt;p&gt;If you are working with a queue or a stack, you can always usse the classic where loop&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;where !stack.empty?&lt;/span&gt;
&lt;span class="err"&gt;  ghost = stack.pop&lt;/span&gt;
&lt;span class="err"&gt;  pacman.chomp(ghost)&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yet every so often you will get to some problem where a classic for loop would be perfect. This is where it becomes awkward. Ruby doesn't have a classic for loop.&lt;/p&gt;
&lt;p&gt;There is a for loop. But it is not C style for loop. Instead it loops over a collection. Usually a list or a range.&lt;/p&gt;
&lt;p&gt;This is how it works. This will go by each element.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;for i in list do&lt;/span&gt;
&lt;span class="err"&gt;  puts i&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In effect it is a wordy version of #each. Therefore most people use #each.&lt;/p&gt;
&lt;p&gt;But we want a C style for! Because sometimes using indices is the right solution to a problem. Even though we don't have something just like it, we can build something close to it.&lt;/p&gt;
&lt;p&gt;Let's say you want something like this from C#&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;Count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WriteLn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can replicate it by doing something like this&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we are using a range. So we will cycle through 0 to list.length - 1. We get that -1 automatically by using the ... range operator that says that we don't want to include the last number. If you wanted to include the last number, we would have written (0..list.length), but this would throw and out of range error when it got to the last item.&lt;/p&gt;
&lt;p&gt;But what do you do when you want to go backwards? We can come up with something as well.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;to_a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;reverse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we start with the range. We turn it into an array, and then we call reverse. Wordy? Yes. Does it get the job done? Also yes. &lt;/p&gt;
&lt;p&gt;The good news is that these are rare scenarios.&lt;/p&gt;</content><category term="log"></category><category term="ruby"></category></entry><entry><title>Functional Programming in Ocaml, 1-2</title><link href="https://oskipa.github.io/functional-programming-in-ocaml-1-2.html" rel="alternate"></link><published>2020-03-14T00:00:00-04:00</published><updated>2020-03-14T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-14:/functional-programming-in-ocaml-1-2.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/"&gt;Functional Programming in OCaml&lt;/a&gt; is an online book compiled by Michael R. Clarkson. It is used by Cornell University for their functional programming course.&lt;/p&gt;
&lt;p&gt;I enjoyed reading chapter one. They explain the goals and purpose of the class that the book supports. It also has a great section on the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/"&gt;Functional Programming in OCaml&lt;/a&gt; is an online book compiled by Michael R. Clarkson. It is used by Cornell University for their functional programming course.&lt;/p&gt;
&lt;p&gt;I enjoyed reading chapter one. They explain the goals and purpose of the class that the book supports. It also has a great section on the history of the  book and the course. It tells how the class was originally based on &lt;a href="http://sarabander.github.io/sicp/html/index.xhtml#SEC_Contents"&gt;Structure and Interpretation of Computer Programs&lt;/a&gt;, (SICP). From the challenges of teaching SICP, they changed languages, from Scheme to OCaml, and they developed the textbook from their class notes. This is fascinating because it is a similar experience that lead to the development of &lt;a href="https://racket-lang.org/"&gt;Racket&lt;/a&gt; and the supporting book &lt;a href="https://htdp.org/"&gt;How To Design Programs&lt;/a&gt;. I will probably talk more about how SICP, a beloved textbook, lead to the creation of other books in a future entry.&lt;/p&gt;
&lt;p&gt;Chapter 2 is an introduction to OCaml as a language. I have read a number of tutorials and several chapters on other OCaml books, and "Functional Programming in Ocaml" seems to be one of the clearest explanations on the basics of OCaml. If for some reason you didn't understand the topic well enough from this text, at the end of the chapter the authors tell you which chapters from others OCaml books you should read to get an alternate explanation of the same topics.&lt;/p&gt;
&lt;p&gt;There is a caveat to the previous statement. It will be clear if you have a basic understanding on lambda calculus and you are familiar with how modern  mathematics defines concepts. If you are not familiar with these, the text should be more challenging. &lt;/p&gt;
&lt;p&gt;The exercises for chapter 2 were good. You get to face the difference between integer operators such as +, -, * , /, versus the floating point operators, like +., -., * . / .. &lt;/p&gt;</content><category term="log"></category><category term="ocaml"></category><category term="notes"></category></entry><entry><title>When you Are New To Rails</title><link href="https://oskipa.github.io/when-you-are-new-to-rails.html" rel="alternate"></link><published>2020-03-09T00:00:00-04:00</published><updated>2020-03-09T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-09:/when-you-are-new-to-rails.html</id><summary type="html">&lt;p&gt;Are you an experienced developer? Have you been tasked to help out in a Rails project? Do you feel confused because there are no 'require' statements and variables seem to mushroom out of nowhere? Does Rails seem too magical to you? &lt;/p&gt;
&lt;p&gt;If this describes you, don't worry. I have gathered …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Are you an experienced developer? Have you been tasked to help out in a Rails project? Do you feel confused because there are no 'require' statements and variables seem to mushroom out of nowhere? Does Rails seem too magical to you? &lt;/p&gt;
&lt;p&gt;If this describes you, don't worry. I have gathered this quick list of pointers to help you find your bearing. Hopefully they will make Rails more logical and less magic.&lt;/p&gt;
&lt;h3&gt;Rails loads all objects found under the 'app' directory into the global scope&lt;/h3&gt;
&lt;p&gt;This is why you don't see 'require' statements. Most objects are available in the global scope.&lt;/p&gt;
&lt;p&gt;Why? Think of it as a radical kind of Don't Repeat Yourself (DRY). Whether you think this is a good idea doesn't matter. This is a Rails convention.&lt;/p&gt;
&lt;p&gt;The title statement may be a gross oversimplification. Yet it will be helpful if you assume this is true unless proven wrong. &lt;/p&gt;
&lt;h3&gt;Carefully read the error messages&lt;/h3&gt;
&lt;p&gt;Ruby errors are usually useful. They tell you what went wrong along with the location where the problem happened.&lt;/p&gt;
&lt;p&gt;Ruby's error stack trace will usually give you the file and line number where the failure has happened. This is key for solving problems. The stack trace will usually have a mix of code from our application and from Ruby libraries, commonly called gems. &lt;/p&gt;
&lt;p&gt;Read them like this: starting from the top, scan line by line until you recognize a file from your application. Identify the file and line number, and start your debugging there. &lt;/p&gt;
&lt;h3&gt;Learn about Ruby's method dispatch and reflection&lt;/h3&gt;
&lt;p&gt;Ruby does what you expect until it doesn't. It will all seem magical and confusing unless you understand how method dispatch works.&lt;/p&gt;
&lt;p&gt;Method dispatch is Ruby's process of looking for a method definition to execute it. When you call 'batman.punch', method dispatch is trying to find where the '.punch' is. It start looking for a definition in the object's class, and then it goes up the object's ancestors. That is the basic idea.  &lt;/p&gt;
&lt;p&gt;The basic idea is also wrong. It is more complicated than that. Read this blog post to get an accurate picture: &lt;a href="https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/"&gt;How Ruby method dispatch works&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ruby has a strong reflection system. You can query a lot of information from an object. Using reflection methods is more useful if you understand how method dispatch works. But even if you don't, the following two methods will be useful right away.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;batman.inspect&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;'.inspect' gives you a string representation of the 'batman' object. Useful in the interactive ruby shell (irb), in the debugger, or  when printing to the log or a debugger via a 'puts object.inspect'.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;batman.methods&lt;/span&gt;
&lt;span class="err"&gt;batman.methods.sort&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;'.methods' gives you an array of all of the methods that the 'batman' object can respond to.  If you add '.sort', then they will be sorted alphabetically.&lt;/p&gt;
&lt;p&gt;If you want more in depth information, read chapters 2 and 3 from the book &lt;a href="https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2"&gt;Metaprogramming Ruby 2&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;The docs: Ruby Doc, Rails Guides, The Rail Way, and the source code&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ruby-doc.org/"&gt;Ruby Doc&lt;/a&gt; should help you if you have questions about the language. The documentation is well written and useful. Ruby is programmer friendly, so if want a method to do something to an array, it most likely exists. I often consult &lt;a href="https://ruby-doc.org/core-2.7.0/Array.html"&gt;Array&lt;/a&gt;, &lt;a href="https://ruby-doc.org/core-2.7.0/Hash.html"&gt;Hash&lt;/a&gt;, &lt;a href="https://ruby-doc.org/core-2.7.0/String.html"&gt;String&lt;/a&gt;, and &lt;a href="https://ruby-doc.org/core-2.7.0/Enumerable.html"&gt;Enumerable&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://guides.rubyonrails.org/"&gt;Rails Guides&lt;/a&gt; should be your first option to learn anything about Rails. For example, if you are learning about Active Record or how to make a configuration change, you should consult this site first.&lt;/p&gt;
&lt;p&gt;You can't find what you are looking for?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://leanpub.com/tr5w"&gt;The Rails Way&lt;/a&gt; should be your next stop. Look for the correct Rails version for your application. It has clear and in-depth explanations on how the different parts of Rails work. &lt;/p&gt;
&lt;p&gt;Still mystified or confused?&lt;/p&gt;
&lt;p&gt;Read &lt;a href="https://github.com/rails/rails"&gt;Rails' source code&lt;/a&gt;. It is recommended for you to look the source code up if all of the above have failed. Read it if you are curious on how something is put together. Read it if you need to check exactly when some feature was added or removed. &lt;/p&gt;
&lt;h3&gt;Use a debugger&lt;/h3&gt;
&lt;p&gt;Ruby has two popular command line debuggers, Pry and Byebug. When you add their name your code, it will open an interactive, command line  shell where you can inspect values, query the variables available in the global space, and do a lot more. &lt;/p&gt;
&lt;p&gt;If you have learned about Ruby's method dispatch and Ruby's reflection methods, the debugger will help you understand how everything gets put together.&lt;/p&gt;
&lt;p&gt;The debugger is perhaps the best tool to understand Rails: use it.&lt;/p&gt;
&lt;p&gt;Identify which debugger your app is using. Learn how to use it, and learn some of its commands. If there isn't one installed, spend some time to get Byebug set up.&lt;/p&gt;</content><category term="log"></category><category term="ruby"></category><category term="rails"></category></entry><entry><title>Using Pelican</title><link href="https://oskipa.github.io/using-pelican.html" rel="alternate"></link><published>2020-03-08T00:00:00-05:00</published><updated>2020-03-08T00:00:00-05:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-08:/using-pelican.html</id><summary type="html">&lt;p&gt;I am in the process of cleaning up the site so that I can start writing again. I have decided that I do two kinds of writting. One is very careful; it is essentially writting what should be real articles. The second type are quick learning notes. My ideal site …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I am in the process of cleaning up the site so that I can start writing again. I have decided that I do two kinds of writting. One is very careful; it is essentially writting what should be real articles. The second type are quick learning notes. My ideal site would have a section for those more well thought out pieces and one for the the quicker, study notes.&lt;/p&gt;
&lt;p&gt;After looking for a while, I decided that Pelican should be able to make it easy for me to get these two things done.&lt;/p&gt;
&lt;p&gt;I have found that I have enjoyed working with Pelicank. It is easy to use and easy to customize. The documentation is superb. And if you run into something that is not covered, you can find the answer with a web search.&lt;/p&gt;
&lt;p&gt;I have liked using the make command to build and publish the site. It seems to make things easier.&lt;/p&gt;
&lt;p&gt;Finally, Pelican is easy to understand. After you have worked a bit, you find that most settings are python constants found in the settings page. There are few surprises, for which I am grateful.&lt;/p&gt;</content><category term="log"></category><category term="python"></category><category term="static site"></category></entry><entry><title>Django, first impressions</title><link href="https://oskipa.github.io/django-first-impressions.html" rel="alternate"></link><published>2020-03-07T00:00:00-05:00</published><updated>2020-03-07T00:00:00-05:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-07:/django-first-impressions.html</id><summary type="html">&lt;p&gt;I am working through the Django tutorial. Here are some thoughts.&lt;/p&gt;
&lt;p&gt;There really isn't any controllers. Interesting.&lt;/p&gt;
&lt;p&gt;The instant admin area is amazing. &lt;/p&gt;
&lt;p&gt;Pluggable apps is such a great idea.&lt;/p&gt;
&lt;p&gt;The way to define fields seems pretty straight forward. Using a more object style versus a more ruby-like dsl seems …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I am working through the Django tutorial. Here are some thoughts.&lt;/p&gt;
&lt;p&gt;There really isn't any controllers. Interesting.&lt;/p&gt;
&lt;p&gt;The instant admin area is amazing. &lt;/p&gt;
&lt;p&gt;Pluggable apps is such a great idea.&lt;/p&gt;
&lt;p&gt;The way to define fields seems pretty straight forward. Using a more object style versus a more ruby-like dsl seems to help because finding the documentation should be easier.&lt;/p&gt;
&lt;p&gt;This is different from other frameworks. I like the idea of having a language module as the components.&lt;/p&gt;</content><category term="log"></category><category term="python"></category><category term="django"></category></entry><entry><title>A Friendly GUI Debugger for Ruby</title><link href="https://oskipa.github.io/ruby-gui-debugger.html" rel="alternate"></link><published>2020-03-01T00:00:00-05:00</published><updated>2020-03-01T00:00:00-05:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-01:/ruby-gui-debugger.html</id><summary type="html">&lt;p&gt;I have been learning Smalltalk. Smalltalk is very similar to Ruby. And Smalltalk have these great programming tools. I am particularly impressed by the object browser and it debugger. Smalltalk was designed so that the system would be learnable. If you wondered how something worked, you could inspect the object …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have been learning Smalltalk. Smalltalk is very similar to Ruby. And Smalltalk have these great programming tools. I am particularly impressed by the object browser and it debugger. Smalltalk was designed so that the system would be learnable. If you wondered how something worked, you could inspect the object and see how it was put together.&lt;/p&gt;
&lt;p&gt;Ruby is very similar to Smalltalk. And pry and byebug along with irb and the rails console  are a command line version of the Smalltalk debugger and object browser. Yet it requires some level of training to use it. You have to know which commands to use that belong to byebug or to ruby to get the information that you are looking for.&lt;/p&gt;
&lt;p&gt;Although I understand that many experienced rubyists may find the command line interface for the debuggers better, a GUI front for byebug would be a great help for beginners. These biginners could be both people new to coding or experienced programmers new to Ruby, who are used to these kinds of tools.&lt;/p&gt;
&lt;p&gt;I am hoping to have the time to create a simple prototype of what this GUI could look like, and then try it out. Who knows? Maybe I will agree with the rest of the community and decide that the command line interface is superior. &lt;/p&gt;</content><category term="log"></category><category term="ruby"></category><category term="metaprogramming"></category><category term="book"></category></entry></feed>