<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dada Structures and Algorithms - log</title><link href="https://oskipa.github.io/" rel="alternate"></link><link href="https://oskipa.github.io/feeds/log.atom.xml" rel="self"></link><id>https://oskipa.github.io/</id><updated>2020-03-09T00:00:00-04:00</updated><entry><title>When you Are New To Rails</title><link href="https://oskipa.github.io/when-you-are-new-to-rails.html" rel="alternate"></link><published>2020-03-09T00:00:00-04:00</published><updated>2020-03-09T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-09:/when-you-are-new-to-rails.html</id><summary type="html">&lt;p&gt;Are you an experienced developer? Have you been tasked to help out in a Rails project? Do you feel confused because there are not include statements and variables seem to mushroom out of nowhere? Does Rails seem too magical to you? &lt;/p&gt;
&lt;p&gt;If this describes you, don't worry. I have gathered …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Are you an experienced developer? Have you been tasked to help out in a Rails project? Do you feel confused because there are not include statements and variables seem to mushroom out of nowhere? Does Rails seem too magical to you? &lt;/p&gt;
&lt;p&gt;If this describes you, don't worry. I have gathered this quick list of pointers to help you find your bearing. Hopefully they will make Rails more logical and less magic.&lt;/p&gt;
&lt;h3&gt;Rails loads all objects found under the 'app' directory into the global scope&lt;/h3&gt;
&lt;p&gt;This is why you don't see 'require' statements. Most objects are available in the global scope.&lt;/p&gt;
&lt;p&gt;Why? Think of it as a radical kind of Don't Repeat Yourself (DRY). Whether you think it is a good idea doesn't matter. This is the Rails convention.&lt;/p&gt;
&lt;p&gt;The title statement may be a gross oversimplification. Yet it will be helpful if you assume this is true unless proven wrong. &lt;/p&gt;
&lt;h3&gt;Carefully read the error messages&lt;/h3&gt;
&lt;p&gt;Ruby errors are usually useful. They tell you what went wrong along with the location where the problem happened.&lt;/p&gt;
&lt;p&gt;Ruby's error stack trace will usually give you the file and line number where the failure has happened. This is key for solving problems. The stack trace will usually have a mix of code from our application and from Ruby libraries, commonly called gems. &lt;/p&gt;
&lt;p&gt;Read them like this. Starting from the top, scan line by line until you recognize a file from your application. Identify the file and line number, and start your debugging there. &lt;/p&gt;
&lt;h3&gt;Learn about Ruby's method dispatch and reflection&lt;/h3&gt;
&lt;p&gt;Ruby does what you expect; until it doesn't. It will all seem magical and confusing until you understand how method dispatch works.&lt;/p&gt;
&lt;p&gt;Method dispatch is Ruby's process of looking for a method definition to execute it. When you call 'batman.punch', method dispatch is trying to find where the '.punch' is. It start looking for a definition in the object's class, and then it goes up the ancestors. That is the basic idea.  &lt;/p&gt;
&lt;p&gt;The basic idea is also wrong. It is more complicated than that. Read this blog post to get an accurate picture: &lt;a href="https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/"&gt;How Ruby method dispatch works&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ruby has a strong reflection system. You can query a lot of information from an object. Using reflection methods are more useful if you understand how method dispatch works. But even if you don't, the following two methods will be useful right away.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;batman.inspect
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;'.inspect' gives you a string representation of the 'batman' object. Useful in the interactive ruby shell (irb), in the debugger, or  when printing to the log or a debugger via a 'puts object.inspect'.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;batman.methods
batman.methods.sort
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;'.methods' gives you an array of all of the methods that the 'batman' object can respond to.  If you add '.sort', then they will be sorted alphabetically.&lt;/p&gt;
&lt;p&gt;If you want more in depth information, read chapters 2 and 3 from the book &lt;a href="https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2"&gt;Metaprogramming Ruby 2&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;The docs: Rails Guides, The Rail Way, and the source code&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://guides.rubyonrails.org/"&gt;Rails Guides&lt;/a&gt; should be your first option to learn anything about Rails. For example, if you are learning about Active Record or how to make a configuration change, you should consult this site first.&lt;/p&gt;
&lt;p&gt;You can't find what you are looking for?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://leanpub.com/tr5w"&gt;The Rails Way&lt;/a&gt; should be your next stop. Look for the correct Rails version for your application. It has clear and in-depth explanations on how the different parts of Rails work. &lt;/p&gt;
&lt;p&gt;Still mystified or confused?&lt;/p&gt;
&lt;p&gt;Read &lt;a href="https://github.com/rails/rails"&gt;Rails' source code&lt;/a&gt;. It is more or less common and recommended for you to look the source code up if all of the above have failed. Or if you are curious on how something is put together. Or if you need to check exactly when some feature was added or removed. &lt;/p&gt;
&lt;h3&gt;Use a debugger&lt;/h3&gt;
&lt;p&gt;Ruby has two popular command line debuggers, Pry and Byebug. When you add their name your code, it will open an interactive, command line  shell where you can inspect values, query the variables available in the global space, and do a lot more. &lt;/p&gt;
&lt;p&gt;If you have learned about Ruby's method dispatch and Ruby's reflection methods, the debugger will help you understand how everything gets put together.&lt;/p&gt;
&lt;p&gt;The debugger is perhaps the best tool to understand Rails. Use it.&lt;/p&gt;
&lt;p&gt;Identify which debugger your app is using. Learn how to use it, and learn some of its commands. If there isn't one installed, spend some time to get Byebug set up.&lt;/p&gt;</content><category term="log"></category><category term="ruby"></category><category term="rails"></category></entry><entry><title>Using Pelican</title><link href="https://oskipa.github.io/using-pelican.html" rel="alternate"></link><published>2020-03-08T00:00:00-05:00</published><updated>2020-03-08T00:00:00-05:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-08:/using-pelican.html</id><summary type="html">&lt;p&gt;I am in the process of cleaning up the site so that I can start writing again. I have decided that I do two kinds of writting. One is very careful; it is essentially writting what should be real articles. The second type are quick learning notes. My ideal site …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I am in the process of cleaning up the site so that I can start writing again. I have decided that I do two kinds of writting. One is very careful; it is essentially writting what should be real articles. The second type are quick learning notes. My ideal site would have a section for those more well thought out pieces and one for the the quicker, study notes.&lt;/p&gt;
&lt;p&gt;After looking for a while, I decided that Pelican should be able to make it easy for me to get these two things done.&lt;/p&gt;
&lt;p&gt;I have found that I have enjoyed working with Pelicank. It is easy to use and easy to customize. The documentation is superb. And if you run into something that is not covered, you can find the answer with a web search.&lt;/p&gt;
&lt;p&gt;I have liked using the make command to build and publish the site. It seems to make things easier.&lt;/p&gt;
&lt;p&gt;Finally, Pelican is easy to understand. After you have worked a bit, you find that most settings are python constants found in the settings page. There are few surprises, for which I am grateful.&lt;/p&gt;</content><category term="log"></category><category term="python"></category><category term="static site"></category></entry><entry><title>Django, first impressions</title><link href="https://oskipa.github.io/django-first-impressions.html" rel="alternate"></link><published>2020-03-07T00:00:00-05:00</published><updated>2020-03-07T00:00:00-05:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-07:/django-first-impressions.html</id><summary type="html">&lt;p&gt;I am working through the Django tutorial. Here are some thoughts.&lt;/p&gt;
&lt;p&gt;There really isn't any controllers. Interesting.&lt;/p&gt;
&lt;p&gt;The instant admin area is amazing. &lt;/p&gt;
&lt;p&gt;Pluggable apps is such a great idea.&lt;/p&gt;
&lt;p&gt;The way to define fields seems pretty straight forward. Using a more object style versus a more ruby-like dsl seems …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I am working through the Django tutorial. Here are some thoughts.&lt;/p&gt;
&lt;p&gt;There really isn't any controllers. Interesting.&lt;/p&gt;
&lt;p&gt;The instant admin area is amazing. &lt;/p&gt;
&lt;p&gt;Pluggable apps is such a great idea.&lt;/p&gt;
&lt;p&gt;The way to define fields seems pretty straight forward. Using a more object style versus a more ruby-like dsl seems to help because finding the documentation should be easier.&lt;/p&gt;
&lt;p&gt;This is different from other frameworks. I like the idea of having a language module as the components.&lt;/p&gt;</content><category term="log"></category><category term="python"></category><category term="django"></category></entry><entry><title>A Friendly GUI Debugger for Ruby</title><link href="https://oskipa.github.io/ruby-gui-debugger.html" rel="alternate"></link><published>2020-03-01T00:00:00-05:00</published><updated>2020-03-01T00:00:00-05:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-03-01:/ruby-gui-debugger.html</id><summary type="html">&lt;p&gt;I have been learning Smalltalk. Smalltalk is very similar to Ruby. And Smalltalk have these great programming tools. I am particularly impressed by the object browser and it debugger. Smalltalk was designed so that the system would be learnable. If you wondered how something worked, you could inspect the object …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have been learning Smalltalk. Smalltalk is very similar to Ruby. And Smalltalk have these great programming tools. I am particularly impressed by the object browser and it debugger. Smalltalk was designed so that the system would be learnable. If you wondered how something worked, you could inspect the object and see how it was put together.&lt;/p&gt;
&lt;p&gt;Ruby is very similar to Smalltalk. And pry and byebug along with irb and the rails console  are a command line version of the Smalltalk debugger and object browser. Yet it requires some level of training to use it. You have to know which commands to use that belong to byebug or to ruby to get the information that you are looking for.&lt;/p&gt;
&lt;p&gt;Although I understand that many experienced rubyists may find the command line interface for the debuggers better, a GUI front for byebug would be a great help for beginners. These biginners could be both people new to coding or experienced programmers new to Ruby, who are used to these kinds of tools.&lt;/p&gt;
&lt;p&gt;I am hoping to have the time to create a simple prototype of what this GUI could look like, and then try it out. Who knows? Maybe I will agree with the rest of the community and decide that the command line interface is superior. &lt;/p&gt;</content><category term="log"></category><category term="ruby"></category><category term="metaprogramming"></category><category term="book"></category></entry></feed>