<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dada Structures and Algorithms - article</title><link href="https://oskipa.github.io/" rel="alternate"></link><link href="https://oskipa.github.io/feeds/article.atom.xml" rel="self"></link><id>https://oskipa.github.io/</id><updated>2020-06-03T00:00:00-04:00</updated><entry><title>Frameworks Should Make it Easy</title><link href="https://oskipa.github.io/frameworks-should-make-it-easy.html" rel="alternate"></link><published>2020-06-03T00:00:00-04:00</published><updated>2020-06-03T00:00:00-04:00</updated><author><name>Hugo Estrada</name></author><id>tag:oskipa.github.io,2020-06-03:/frameworks-should-make-it-easy.html</id><summary type="html">&lt;p&gt;Frameworks should make your work easier. Yes, there will be moments when you will have to fight with the framework to get something done. These cases should be rare. In general, you should not think about a framework or be happy when using it. &lt;/p&gt;
&lt;p&gt;Ideally a framework lets you get â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;Frameworks should make your work easier. Yes, there will be moments when you will have to fight with the framework to get something done. These cases should be rare. In general, you should not think about a framework or be happy when using it. &lt;/p&gt;
&lt;p&gt;Ideally a framework lets you get your work done. It makes it easy to customize some behavior. It gets out of the way in other cases. It becomes invisible when you are working with business logic.&lt;/p&gt;
&lt;p&gt;DotNet's Mvc and PHP's CodeIgniter are two frameworks that meet most of these criteria. Elixir's Phoenix seems to fit it too, but I need more experience working with it to make a stronger statement.&lt;/p&gt;
&lt;p&gt;If you find yourself fighting too much with the framework, it may be an indication that you may move onto something else. It may be faster and easier to write something yourself. Toss it.&lt;/p&gt;</content><category term="article"></category><category term="software engineering"></category><category term="programming"></category></entry></feed>